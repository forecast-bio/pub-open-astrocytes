---
title: '<span class="dark-highlight">OpenAstrocytes</span>'
subtitle: '<span class="dark-highlight">AI-ready dynamic activity from the astrocyte network</span>'

title-block-banner: img/astro-banner.png
author-title: ''
affiliation-title: ''
published-title: 'Latest'
# modified-title: 'Updated'

author:
    - name: Maxine Levesque
      email: maxine@forecast.bio
    #   affiliation: " "

    - name: Kira Poskanzer
      email: kira@forecast.bio

    - name: " "

date: 31 October 2025
# date-modified: 31 October 2025

# abstract-title: "TL;DR"
# abstract: |+
#     This is a test

#     Hello, some more.

toc-title: "OpenAstrocytes"

fig-format: svg
filters:
  - inline-svg

reference-location: margin
# cap-location: margin
# citation-location: margin
bibliography: references.bib
csl: csl/science.csl
---

## tl;dr

Astrocytes make up about a third of the cells in your brain, and form a second, distinct brain network from the more-studied neuronal network. As neuroscience has discovered in only the last few years, the astrocyte network carries out extremely important computations 

 

---

## Background

The human brain is about one-third neurons. But two-thirds of it isn't; and, in recent years, the neuroscience field has become more acutely aware of the incredible importance of the roles played by those other sorts of cells.

::: {#fig-synapse-diagram .column-body}
![](img/synapse-diagram.png)

Schematic diagram of the **tripartite synapse**. Astrocytic processes (green) wrap around most cortical synaptic connections between neurons, allowing astrocytes to integrate the myriad chemical signals sensed in the neuronal chatter, and downstream, to incorporate that information with other signals about the local brain network sensed from other parts of the extracellular space.
:::

One of those other thirds is made up of **astrocytes**---one of the principal kinds of *glia* ("glue", referencing old theories of their supposed passivity in brain function). Astrocytes form a cellular network woven between the neurons [@fig-synapse-diagram], and as recent work has demonstrated [@cahill2024network, CITEs], 

### Astrocyte calcium dynamics
All biological cells must incorporate a massive number of datapoints, coming both from the outside world and also from the internal processes of the cell; indeed, this binding-together of disparate interactions into a shared, coherent, soliton-like packet is, perhaps, what makes life *life* [CITE]. While all the diverse kinds of cells across the entire diverse tree of life have unique approaches to sensing and making sense of these signals, because of shared evolutionary history, a few common structural threads span vast swaths of this diversity. One of those central commonalities is the use of intracellular calcium signaling.

But astrocytes have a 

::: {#fig-astro-video .column-screen-inset-shaded}
{{< video img/astro-events.mov >}}

(**Left**) Dynamics of astrocyte calcium, as recorded with two-photon imaging of mouse cortical slices expressing the calcium-binding fluorescent indicator GCaMP. (**Right*) . Reproduced from @wang2019accurate.
:::

 

---

## Architecture

AI

```{python}
import matplotlib.pyplot as plt
from forecast_style import HouseStyle

with HouseStyle() as s:
    plt.figure()
    plt.plot( [0, 1], [3, 2], '-' )
```

### Backbone: Distributed, typed WebDatasets with `atdata`

The OpenAstrocytes dataset is built on [`atdata`](https://github.com/foundation-ac/atdata), an open-source package we're developing at Forecast for distributed, interoperable usage of AI-ready datasets.[The original motivation for `atdata` internally was to have fast infrastructure for putting together our rich, multimodal datasets to speed up the iteration cycle for our R&D;]{.aside} `atdata` is built on the open [WebDataset](https://github.com/webdataset/webdataset) format, designed for use as a high-performance AI I/O layer.

`atdata` makes it straightforward to understand structured data from remote repositories:

```{python}
#| echo: false

import sys
from copy import copy

import numpy as np
from numpy.typing import NDArray

import matplotlib.pyplot as plt
from matplotlib.axes import Axes
from forecast_style import HouseStyle
```

```{python}
#| echo: false

# Plotting helpers

def plot_micrograph( s: HouseStyle, image: NDArray,
            ax: Axes | None = None,
            scale_x: float = 1.,
            scale_y: float = 1.,
            scale_bar: float = 100.,
            **kwargs
        ):

    s.show_micrograph( ax, image,
        scale_x = scale_x,
        scale_y = scale_y,
        **kwargs
    )
    # plt.imshow( sample_view.image[0] )
    s.label(
        data_xlim = (0, scale_bar),
        data_ylim = None,
    )
    plt.xticks( [0, scale_bar], ['0', '100 $\\mu$m'], ha = 'left' )
    plt.yticks( [] )

```

```{python}
#| label: fig-example-image
#| fig-column: body-outset-right
#| fig-cap: Example data from the OpenAstrocytes dataset, showing mean calcium fluorescence in an *ex vivo* brain slice from a mouse over 60 frames (about one minute).
import atdata
import astrocytes

# Dataset sample type schemas
from toile.schema import (
    Frame,
)
from astrocytes.schema import (
    BathApplicationFrame,
)

dataset = (
    astrocytes.data.bath_application
        .as_type( BathApplicationFrame )
)

# Pop off a single sample
exemplar = next( x for x in dataset.ordered( batch_size = None ) )

# Pop off a single batch
n_batch = 60
batch = next( x for x in dataset.ordered( batch_size = n_batch) )
batch_summary = np.quantile( batch.image[:, 0], 0.75, axis = 0 )

with HouseStyle() as s:
    fig, ax = plt.subplots( figsize = (8, 8) )
    plot_micrograph( s, batch_summary, ax,
        scale_x = exemplar.scale_x,
        scale_y = exemplar.scale_y,
        scale_bar = 100.,
        clim = (0, 140),
    )
```

The full documentation for `atdata` can be found on [GitHub](https://github.com/foundation-ac/atdata).

### Datasets

Our initial release of OpenAstrocytes is built from two large collections of previously-published calcium imaging from mouse astrocytes, originally analyzed in @reitman2023norepinephrine and @cahill2024network. In total, these datasets comprise about 1M images, making this release among the the largest open datasets of astrocyte calcium dynamics to date, to our knowledge.

 

------------------------------------------------------------------------

## Demo

Let's take a look at some of the fun structure that we have in the OpenAstrocytes data. Here, we'll be digging into one of the experiments from @cahill2024network, in which *ex vivo* slices from mouse visual cortex had two drugs---baclofen and tACPD^[Baclofen acts as an agonist of the GABA~B~ receptor; tACPD acts as an agonist of the metabotropic glutamate receptor subtypes mGluR2 and mGluR3]---bath-applied across the slice. Here, we'll use the OpenAstrocytes dataset with contemporary to give views into the differences between these two compounds' effects on brain networks.

#### Identifying local physiological responses

Components:

* Image plot of single-patch
    * Grid of images for patch over time
    * PC x time plot for this patch

```{python}
#| code-fold: true

first_movie_id = 'd22f6a65-b3e2-46c2-ba5c-551920af1fe3'

# test_movie_id = '5667b0c5-0896-42cf-b0c0-b88d48473797'
# test_movie_id = 'd22f6a65-b3e2-46c2-ba5c-551920af1fe3'

# test_patch_i = 9
# test_patch_j = 12

#

import atdata
from astrocytes.schema import BathApplicationFrame

#

def _get_movie( movie_uuid: str, verbose: bool = False ) -> list[BathApplicationFrame]:
    ds = astrocytes.data.bath_application \
            .as_type( BathApplicationFrame )

    started_movie = False
    recording_frames = []
    if verbose:
        print( 'Iterating frames...' )
    for frame in ds.ordered( batch_size = None ):
        if frame.movie_uuid == movie_uuid:
            if verbose and not started_movie:
                print( 'Snagging correct movie...' )
            started_movie = True
            recording_frames.append( frame )
        else:
            if started_movie:
                # We've moved to a new movie uuid, and so finished up
                if verbose:
                    print( 'Got it!' )
                break
    
    return recording_frames

#

movie_frames = _get_movie( first_movie_id, verbose = True )
```

```{python}
#| code-fold: true
#| label: fig-patch-examples
#| fig-column: page-inset-right
#| fig-cap: Two example patches from the same recording, showing evolution of calcium activity over time relative to bath application of (TODO COMPOUND). (A small Gaussian smoothing kernel in space and time has been applied here, to aid visualization.)

import numpy as np
from scipy.ndimage import convolve, gaussian_filter

#

N_PATCHES_Y = 14
N_PATCHES_X = 14
patch_size_y = movie_frames[0].image[0].shape[0] / N_PATCHES_Y
patch_size_x = movie_frames[0].image[0].shape[1] / N_PATCHES_X

#

test_patches = [
    (10, 12),
    (3, 7),
]

test_patch_frames = []
for cur_i, cur_j in test_patches:

    patch_idx_y = ( int( np.floor( patch_size_y * cur_i ) ),
                    int( np.ceil( patch_size_y * (cur_i + 1) ) ) )
    patch_idx_x = ( int( np.floor( patch_size_y * cur_j ) ),
                    int( np.ceil( patch_size_y * (cur_j + 1) ) ) )

    test_patch_frames.append(
        np.array( [ 
            frame.image[0][patch_idx_y[0]:patch_idx_y[1], :][:, patch_idx_x[0]:patch_idx_x[1]]
            for frame in movie_frames
        ] )
    )

# kernel = np.ones( (7, 3, 3) )
# kernel = kernel / np.sum( kernel )
# cur_patch_frames = convolve( cur_patch_frames, kernel )

test_patch_frames_filtered = [
    gaussian_filter( fs, sigma = (3., 0.6, 0.6) )
    for fs in test_patch_frames
]

#

dt = movie_frames[3].t
t_intervene = 300

cmax = 110
i_frame_compare = (250, 350, 450, 550, 650, 750)

n_patches = len( test_patch_frames_filtered )
n_frame_compare = len( i_frame_compare )

#

with HouseStyle() as s:

    fig, axs = plt.subplots( n_patches, n_frame_compare,
        figsize = (10, 4),
        sharey = True,
    )

    for i_patch in range( n_patches ):

        cur_patch_frames = test_patch_frames_filtered[i_patch]

        for i_t in range( n_frame_compare ):

            axs[i_patch, i_t].imshow(
                cur_patch_frames[i_frame_compare[i_t], :, :],
                #
                clim = (0, cmax),
                cmap = 'afmhot',
            )
            # plot_micrograph(
            #     s,
            #     cur_patch_frames[i_frame_compare[i_t], :, :],
            #     axs[i_patch, i_t],
            #     #
            #     scale_x = movie_frames[0].scale_x,
            #     scale_y = movie_frames[0].scale_y,
            #     scale_bar = 50.,
            #     clim = (0, cmax),
            #     cmap = 'plasma',
            # )

            if i_patch == 0:
                t_val = i_frame_compare[i_t] * dt - t_intervene
                axs[i_patch, i_t].set_title( f'{t_val:+0.0f}s', fontsize = 12 )

            if i_patch == (n_patches - 1) and i_t == 0:
                axs[i_patch, i_t].tick_params( axis = 'x', length = 3 )
                axs[i_patch, i_t].set_xticks( [-0.5, patch_size_x+0.5], ['0', f'{movie_frames[0].scale_x * patch_size_x:0.0f} µm'], ha = 'left' )
            else:
                # axs[i_patch, i_t].set_xticks( [-0.5, patch_size_x+0.5], ['', ''] )
                axs[i_patch, i_t].tick_params( axis = 'x', length = 0 )
                axs[i_patch, i_t].set_xticks( [-0.5, patch_size_x+0.5], ['', ''] )
            
            axs[i_patch, i_t].set_yticks( [] )

            if i_t == 0:
                axs[i_patch, i_t].set_ylabel( f'Patch {i_patch+1}' )

    # s.label( xaxis_y = 0 )
    plt.subplots_adjust( wspace = 0.04, hspace = 0. )
    # plt.show()
```

TODO narrative

```{python}
#| code-fold: true
#| label: fig-patch-example-traces
#| column: body-outset-right
#| fig-cap: For each of the two astrocyte network patches shown above in @fig-patch-examples, the time-evolution of three representative embedding PCs relative to the onset of bath application of (TODO COMPOUND). (*N.B.*---A 60s boxcar filter in time has been applied to each PC, leading to blurring of activation edges.)

from tqdm import tqdm

import atdata

import astrocytes
from astrocytes._datasets._embeddings import (
    PatchEmbeddingTrace,
)

#

t_intervene = 300
baseline_window = (-100, -15)
plot_window = (-100, 240)

#

wds_url = (
    'https://data.forecastbio.cloud/testing/patch-pc-traces/bath-application/'
    + 'bath_app-dinov3_vit7b16-pca64-smooth84.tar'
)
ds = atdata.Dataset[PatchEmbeddingTrace]( wds_url )

test_traces = [ None for _ in test_patches ]
for trace in tqdm( ds.ordered( batch_size = None ) ):
    try:
        assert trace.metadata is not None and 'uuid' in trace.metadata
        assert trace.metadata['uuid'] == first_movie_id
        
        for i_patch, (cur_i, cur_j) in enumerate( test_patches ):
            if trace.i_patch == cur_i and trace.j_patch == cur_j:
                test_traces[i_patch] = trace
        
        should_finish = True
        for x in test_traces:
            if x is None:
                should_finish = False
        if should_finish:
            break

    except:
        # print( trace.metadata['uuid'], trace.i_patch, trace.j_patch )
        continue

# test_sample = next( iter( ds.ordered( batch_size = None ) ) )
# print( test_sample.values.shape )
# print( test_sample.ts.shape )

import matplotlib.pyplot as plt
from forecast_style import HouseStyle

def _baseline_normalize( ts, ys, window ):
    filter_cur = (
        (ts >= window[0])
        & (ts < window[1])
    )
    mean = np.mean( ys[filter_cur] )
    std = np.std( ys[filter_cur] )
    return (ys - mean) / std, mean, std

#

causal_offset = (84 * dt) / 2.
t_rel = test_traces[0].ts - t_intervene + (causal_offset)

with HouseStyle( grids = True ) as s:

    fig, axs = plt.subplots( n_patches, 1,
        figsize = (7, 7),
        sharex = True,
        # sharey = True,
    )

    for i_patch in range( n_patches ):
        ax = axs[i_patch]
        cur_trace = test_traces[i_patch]

        values_0_norm, mean_0, std_0 = \
            _baseline_normalize( t_rel, cur_trace.values[0, :], baseline_window )    
        values_1_norm, mean_1, std_1 = \
            _baseline_normalize( t_rel, cur_trace.values[1, :], baseline_window )
        values_2_norm, mean_2, std_2 = \
            _baseline_normalize( t_rel, cur_trace.values[4, :], baseline_window )

        filter_plot = (
            (t_rel >= plot_window[0])
            & (t_rel < plot_window[1])
        )

        ax.plot( t_rel[filter_plot], values_0_norm[filter_plot], 'C0-', label = 'PC 1' )
        ax.plot( t_rel[filter_plot], values_1_norm[filter_plot], 'C2-', label = 'PC 2' )
        ax.plot( t_rel[filter_plot], values_2_norm[filter_plot], 'C3-', label = 'PC 5' )
        
        yl = (-5.5, 10.5)

        ax.fill_between( [0, plot_window[1]], yl[0], yl[1], color = 'k', alpha = 0.05, linewidth = 0 )

        ax.plot( plot_window, [0, 0], 'k-', linewidth = 1 )
        ax.plot( [plot_window[0], plot_window[0]], yl, 'k-', linewidth = 1 )

        ax.set_xticks( [-90, 0, 60, 120, 180, 240] )
        # ax.set_yticks( [0, 5, 10] )
        ax.set_xlim( plot_window )
        ax.set_ylim( yl )

        ax.set_ylabel( f'Patch {i_patch + 1}' )

        if i_patch == (n_patches - 1):
            ax.set_xlabel( 'Time (s)' )
            # ax.set_ylabel( '∆ (baseline SD)' )

            plt.legend( fontsize = 12, loc = 'upper left' )

            ax.text( 5, 8.5, '+ Drug', alpha = 0.5 )
    
    # s.label(
    #     xlabel = 'Time (s)',
    #     ylabel = '∆ (SDs)',
    # )

# print( dt * 84 )

```

TODO Narrative

::: {.panel-tabset}

#### PC 1

```{python}
#| code-fold: true
#| label: fig-patch-example-grid-pc1
#| column: screen-inset
#| fig-cap: TODO

from astrocytes._datasets._embeddings import PatchEmbeddingTrace

#

def _get_movie_traces( movie_uuid: str, verbose: bool = False ) -> list[list[PatchEmbeddingTrace]]:

    # TODO Created `wids` indexed WebDataset for easier indexing in demos

    wds_url = (
        'https://data.forecastbio.cloud/testing/patch-pc-traces/bath-application/'
        + 'bath_app-dinov3_vit7b16-pca64-smooth84.tar'
    )
    ds = atdata.Dataset[PatchEmbeddingTrace]( wds_url )

    started_movie = False
    movie_traces: list[PatchEmbeddingTrace] = []

    if verbose:
        print( 'Iterating traces...' )
    for trace in ds.ordered( batch_size = None ):
        try:
            assert trace.metadata is not None
            assert 'uuid' in trace.metadata

            if trace.metadata['uuid'] == movie_uuid:
                if verbose and not started_movie:
                    print( 'Snagging correct movie...' )
                started_movie = True
                movie_traces.append( trace )

            else:
                if started_movie:
                    # We've moved to a new movie uuid, and so finished up
                    if verbose:
                        print( 'Got it!' )
                    break
        except:
            print( 'Skipping trace - no metadata' )
            continue
    
    # Arrange nicely
    ret = [
        [
            None
            for j in range( N_PATCHES_X )
        ]
        for i in range( N_PATCHES_Y )
    ]

    for trace in movie_traces:
        ret[trace.i_patch][trace.j_patch] = trace

    return ret


##

# Collate full dataset

first_movie_traces = _get_movie_traces( first_movie_id, verbose = False )

# Do plot

i_pc = 0

with HouseStyle() as s:

    fig, axs = plt.subplots( N_PATCHES_Y, N_PATCHES_X,
        figsize = (16, 12),
        # sharex = True,
        # sharey = True,
    )

    for i in range( N_PATCHES_Y ):
        for j in range( N_PATCHES_X ):
            ax = axs[i, j]
            trace = first_movie_traces[i][j]
            ts_rel = trace.ts - t_intervene + causal_offset

            cur_values_norm, cur_mean, cur_std = \
                _baseline_normalize( t_rel, trace.values[i_pc, :], baseline_window )  

            filter_plot = (
                (ts_rel >= plot_window[0])
                & (ts_rel < plot_window[1])
            )

            ax.plot( ts_rel[filter_plot], cur_values_norm[filter_plot], f'C0-', linewidth = 1.5 )
            
            xl = ax.get_xlim()
            ax.plot( xl, [0, 0], 'k-', linewidth = 1, zorder = -200 )
            # yl = ax.get_ylim()
            yl = (-10.5, 10.5)
            ax.fill_between( [0, xl[1]], yl[0], yl[1], color = 'k', alpha = 0.05, linewidth = 0, zorder = 100 )

            if (i, j) in test_patches:
                ax.fill_between( [xl[0], xl[1]], yl[0], yl[1], facecolor = 'none', edgecolor = f'k', alpha = 0.7, linewidth = 2., zorder = -300 )
            
            ax.set_xlim( xl )
            ax.set_ylim( yl )

            ax.set_yticks( [] )
            ax.set_xticks( [] )
    
    for i in range( 1, N_PATCHES_X ):
        axs[-1, i].set_xticks( [-90, 0, 240], ['', '', ''] )
    axs[-1, 0].set_xticks( [-90, 0, 240], ['–90', '0', '240'], fontsize = 8, rotation = 90 )

    for i in range( 0, N_PATCHES_Y - 1 ):
        # axs[i, 0].set_yticks( [-10, 0, 10], ['', '', ''] )
        pass
    axs[-1, 0].set_yticks( [-10, 0, 10], ['-10', '0', '10'], fontsize = 8 )

    fig.subplots_adjust( wspace = 0.1, hspace = 0.1 )

```

#### PC 2

```{python}
#| code-fold: true
#| label: fig-patch-example-grid-pc2
#| column: screen-inset
#| fig-cap: TODO

# Do plot

i_pc = 1

with HouseStyle() as s:

    fig, axs = plt.subplots( N_PATCHES_Y, N_PATCHES_X,
        figsize = (16, 12),
        # sharex = True,
        # sharey = True,
    )

    for i in range( N_PATCHES_Y ):
        for j in range( N_PATCHES_X ):
            ax = axs[i, j]
            trace = first_movie_traces[i][j]
            ts_rel = trace.ts - t_intervene + causal_offset

            cur_values_norm, cur_mean, cur_std = \
                _baseline_normalize( t_rel, trace.values[i_pc, :], baseline_window )  

            filter_plot = (
                (ts_rel >= plot_window[0])
                & (ts_rel < plot_window[1])
            )

            ax.plot( ts_rel[filter_plot], cur_values_norm[filter_plot], f'C2-', linewidth = 1.5, zorder = 200 )
            
            xl = ax.get_xlim()
            ax.plot( xl, [0, 0], 'k-', linewidth = 1, zorder = -200 )
            # yl = ax.get_ylim()
            yl = (-15.5, 15.5)
            ax.fill_between( [0, xl[1]], yl[0], yl[1], color = 'k', alpha = 0.05, linewidth = 0, zorder = 100 )

            if (i, j) in test_patches:
                ax.fill_between( [xl[0], xl[1]], yl[0], yl[1], facecolor = 'none', edgecolor = f'k', alpha = 0.7, linewidth = 2., zorder = -300 )
            
            ax.set_xlim( xl )
            ax.set_ylim( yl )

            ax.set_yticks( [] )
            ax.set_xticks( [] )
    
    for i in range( 1, N_PATCHES_X ):
        axs[-1, i].set_xticks( [-90, 0, 240], ['', '', ''] )
    axs[-1, 0].set_xticks( [-90, 0, 240], ['–90', '0', '240'], fontsize = 8, rotation = 90 )

    for i in range( 0, N_PATCHES_Y - 1 ):
        # axs[i, 0].set_yticks( [-10, 0, 10], ['', '', ''] )
        pass
    axs[-1, 0].set_yticks( [-15, 0, 15], ['-15', '0', '15'], fontsize = 8 )

    fig.subplots_adjust( wspace = 0.1, hspace = 0.1 )

```

:::

* 3D plot of post-exposure PC changes per-patch

```{python}
#| echo: false

pcs_show = (0, 1, 4)
n_traces_show = 1_000
window_3d = (0, 240)

#

# Collate data
wds_url = (
    'https://data.forecastbio.cloud/testing/patch-pc-traces/bath-application/'
    + 'bath_app-dinov3_vit7b16-pca64-smooth84.tar'
)
ds = atdata.Dataset[PatchEmbeddingTrace]( wds_url )

i_trace = 0
trace_data_show = []
trace_data_raw_show = []
for trace in tqdm( ds.shuffled( batch_size = None ) ):
    ts_rel = trace.ts - t_intervene + causal_offset
    filter_3d = (
        (ts_rel >= window_3d[0])
        & (ts_rel < window_3d[1])
    )

    cur_trace_pcs_post = []
    for i_pc in pcs_show:
        cur_vals_norm, _, _ = _baseline_normalize( t_rel, trace.values[i_pc, :], baseline_window )  
        cur_trace_pcs_post.append( cur_vals_norm[filter_3d] )
    
    trace_data_show.append( np.array( cur_trace_pcs_post ) )
    trace_data_raw_show.append( trace.values[pcs_show, :] )

    i_trace += 1
    if i_trace >= n_traces_show:
        break
    
trace_data_show = np.array( trace_data_show )
trace_data_raw_show = np.array( trace_data_raw_show )
```

Raw values:

```{python}
#| code-fold: true
#| label: fig-patch-3d-raw
#| column: body-outset-right
#| fig-cap: TODO

random_seed = 89
rng = np.random.default_rng( random_seed )

#

n_traces_show_raw = 100
traces_show_raw = rng.permutation( n_traces_show )[:n_traces_show_raw]

with HouseStyle() as s:
    fig = plt.figure( figsize = (6, 6) )
    ax = fig.add_subplot( projection = '3d' )
    ax.view_init( azim = -62 )

    for i_trace in tqdm( traces_show_raw ):
        # start
        ax.scatter(
            trace_data_raw_show[i_trace, 0, 0],
            trace_data_raw_show[i_trace, 1, 0],
            trace_data_raw_show[i_trace, 2, 0],
            color = 'k',
            s = 3
        )
        # end
        ax.scatter(
            trace_data_raw_show[i_trace, 0, -1],
            trace_data_raw_show[i_trace, 1, -1],
            trace_data_raw_show[i_trace, 2, -1],
            facecolor = f'C{i_trace % 4}',
            edgecolor = 'k',
            linewidth = 0.5,
            s = 8
        )
        # trajectory
        ax.plot(
            trace_data_raw_show[i_trace, 0, :],
            trace_data_raw_show[i_trace, 1, :],
            trace_data_raw_show[i_trace, 2, :],
            f'C{i_trace % 4}-',
            linewidth = 0.5,
            alpha = 0.8,
        )

    ax.set_xticks( [0], '' )
    ax.set_yticks( [0], '' )
    ax.set_zticks( [0], '' )

    ax.set_xlabel( f'PC {pcs_show[0]+1}' )
    ax.set_ylabel( f'PC {pcs_show[1]+1}' )
    ax.set_zlabel( f'PC {pcs_show[2]+1}', rotation = 90 )
    
    ax.set_box_aspect(None, zoom=0.82)

```

Normalized:

```{python}
#| code-fold: true
#| label: fig-patch-3d-norm
#| column: body-outset-right
#| fig-cap: TODO

with HouseStyle() as s:
    fig = plt.figure( figsize = (6, 6) )
    ax = fig.add_subplot( projection = '3d' )
    ax.view_init( elev = 20 )

    for i_trace in tqdm( traces_show_raw ):
        # start
        ax.scatter(
            trace_data_show[i_trace, 0, 0],
            trace_data_show[i_trace, 1, 0],
            trace_data_show[i_trace, 2, 0],
            color = 'k',
            s = 3
        )
        # end
        ax.scatter(
            trace_data_show[i_trace, 0, -1],
            trace_data_show[i_trace, 1, -1],
            trace_data_show[i_trace, 2, -1],
            facecolor = f'C{i_trace % 4}',
            edgecolor = 'k',
            linewidth = 0.5,
            s = 8
        )
        # trajectory
        ax.plot(
            trace_data_show[i_trace, 0, :],
            trace_data_show[i_trace, 1, :],
            trace_data_show[i_trace, 2, :],
            f'C{i_trace % 4}-',
            linewidth = 0.5,
            alpha = 0.8,
        )
    
    ax.set_xlim( -32, 32 )
    ax.set_ylim( -32, 32 )
    ax.set_zlim( -12, 52 )

    ax.tick_params(axis='y', which='major', pad=-5)

    ax.set_xticks( [-30, 0, 30], ['', '', ''], fontsize = 12 )
    ax.set_yticks( [-30, 0, 30], ['–30', '', '+30'], rotation = -55, ha = 'left', fontsize = 12 )
    ax.set_zticks( [-10, 0, 50], ['–10', '', '+50'], fontsize = 12 )

    ax.set_xlabel( f'PC {pcs_show[0]+1}', rotation = -14 )
    ax.set_ylabel( f'PC {pcs_show[1]+1}', rotation = 37 )
    ax.set_zlabel( f'PC {pcs_show[2]+1}', rotation = 90 )
    
    ax.set_box_aspect((1, 1, 1.1), zoom=0.85)

    # fig.tight_layout()

```

* Clustering results of post-exposure responses

```{python}
print( 'TODO' )
```

...

``` python
#| code-fold: true
#| fig-cap: A test plot

with HouseStyle() as s:
    xs = np.arange( 0, 600, 5 )
    ys = np.random.randn( *xs.shape )
    plt.plot( xs, ys, '-' )
```

#### Distinguishing impacts of distinct compounds

Components:

* Single-patch comparison for B vs T
    * Grid of images for patch over time
    * (Done) PC x time plot for this patch
* (Done) Population-level impacts on individual PCs
* Plot of projection onto B vs T subspaces over time for individual recordings
* Decoding

...

 

------------------------------------------------------------------------

## Looking ahead

...

#### Building on `atdata`



`atdata`'s typing functionality already helps for keeping datasets sane; but, where keeping track of sample types really shines is when we register *mappings* between types. As an example, take this from the `openastros` library accompanying this pub:

``` python
@atdata.lens
def from_generic( s: ts.Frame ) -> 'BathApplicationFrame':
    
    assert s.metadata is not None
    
    return BathApplicationFrame(
        # TODO
        applied_compound = 'unknown',
        image = s.image,
        t_index = s.metadata['frame']['t_index'],
        t = s.metadata['frame']['t'],
        #
        date_acquired = s.metadata['date_acquired'],
        movie_uuid = s.metadata['uuid'],
    )
```

Under the hood, `atdata.lens` keeps track of the full registry lenses between sample schema types. Because lenses can have a very nice compositional behavior [@nlab:lens], this design enables us, as we're building AI models from a bunch of different sources, to easily and automatically aggregate across our diverse hive of WebDatasets, built across different modalities and experiments, taking advantage of the natural ways these data can be compatibly merged.

The full `atdata` ecosystem is architected to go one step further, placing metadata for type schemas of scientific datasets---and the code for these lenses between them!---in a public, decentralized repository on [ATProto](https://atproto.com), the protocol layer underlying the [Bluesky](https://bsky.social/about) social network. This allows AI coding agents on data science tasks to automatically leverage domain knowledge of structured semantic relationships to decide what data to pull from for a given task.[More on `atdata` soon, including our ATProto appview for the full distributed dataset network with MCP support---sign up for updates to hear first as we push more features to the public release!]{.aside}

#### Loving neurons, too

Of course, the brain *also* is one-third neurons---a fact we certainly wouldn't want to forget. This is why we're building out the OpenAstrocytes repository with newly-collated data from the Allen Brain Observatory [@de2023sharing], also formatted with `atdata` for easy use with existing AI workflows.

``` python
from openastros.datasets import allen
from openastros.datasets.allen.schema import BrainObservatoryFrame

dataset = (
    allen
        .generic.braion_observatory
        .dataset
        .as_type( BrainObservatoryFrame )
)
# Pull an example sample
sample = next( x for x in dataset.shuffled( batch_size = None ) )

with HouseStyle() as s:
    fig, ax = plt.figure( figsize = (8, 8) ))
    plt.imshow( sample.image )
```

We're continuing to collate this fantastic dataset's movies of raw two-photon calcium imaging from neurons in visual cortex, as it provides another phenomenal source of neurobiological imaging data for augmenting fine-tuning workflows; since neuronal and astrocytic imaging share tremendous overlap in latent image statistics, we anticipate that combining large datasets of similar dynamic imaging from the two cell types will provides immense benefit to the study of each.

#### A new kind of data

...

 

------------------------------------------------------------------------

 

#### Acknowledgements

We'd like to thank **Dr. Michelle Cahill** and **Dr. Michael Reitman** for driving the original experimental work and data collection for the images that went into the initial release of OpenAstrocytes presented here.

Support for the production of OpenAstrocytes at Forecast was generously provided by the Special Initiatives division of the [**Astera Institute**](https://astera.org/).

#### Citation

Please reference this work in BibTeX as:

``` bibtex
@article{levesque2025openastrocytes,
  author = {Maxine Levesque and Kira Poskanzer},
  title = {OpenAstrocytes},
  journal = {Forecast Research},
  year = {2025},
  note = {https://forecast.bio/research/open-astrocytes/},
}
```

#### AI use

No language model tools were used to produce any of the code for or writing in this pub.

#### Copyright

Copyright © 2025 Forecast Bio, Inc. The contents of this article are licensed under the Creative Commons [CC-BY 4.0](https://creativecommons.org/licenses/by/4.0/) license.

 

------------------------------------------------------------------------

 

#### References

::: {#refs}
:::